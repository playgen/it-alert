using System.Linq;
using Engine.Components;
using Engine.Entities;
using Engine.Events;
using Engine.Systems;
using Engine.Systems.RNG;
using PlayGen.ITAlert.Simulation.Components.Common;
using PlayGen.ITAlert.Simulation.Components.EntityTypes;
using PlayGen.ITAlert.Simulation.Components.Movement;
using PlayGen.ITAlert.Simulation.Modules.Malware.Components;
using PlayGen.ITAlert.Simulation.Modules.Malware.Events;
using PlayGen.ITAlert.Simulation.Systems.Movement;

namespace PlayGen.ITAlert.Simulation.Modules.Malware.Systems
{
	public class MalwarePropogationSystem : ISystem, ITickableSystem
	{

		private readonly IEntityFactoryProvider _entityFactoryProvider;

		private readonly ComponentMatcherGroup<MalwareGenome, CurrentLocation, MalwarePropogation, MalwareVisibility> _malwareMatcher;

		private readonly ComponentMatcherGroup<Subsystem, GraphNode> _subsystemMatcher;

		private readonly RNGSystem _rngSystem;
		private readonly MovementSystem _movementSystem;
		private readonly EventSystem _eventSystem;

		public MalwarePropogationSystem(IMatcherProvider matcherProvider,
			IEntityFactoryProvider entityFactoryProvider,
			RNGSystem rngSystem,
			MovementSystem movementSystem,
			EventSystem eventSystem)
		{
			_entityFactoryProvider = entityFactoryProvider;
			_rngSystem = rngSystem;
			_movementSystem = movementSystem;
			_eventSystem = eventSystem;

			// TODO: refactor to use tuple matcher
			_malwareMatcher = matcherProvider.CreateMatcherGroup<MalwareGenome, CurrentLocation, MalwarePropogation, MalwareVisibility>();
			_subsystemMatcher = matcherProvider.CreateMatcherGroup<Subsystem, GraphNode>();
		}

		public void Tick(int currentTick)
		{
			foreach (var malwareTupleGroupByLocation in _malwareMatcher.MatchingEntities
				.Where(mt => mt.Component2.Value.HasValue)
				.GroupBy(mt => mt.Component2.Value))
			{
				if (_subsystemMatcher.TryGetMatchingEntity(malwareTupleGroupByLocation.Key.Value, out var subsystemTuple))
				{
					var malwareTuple = malwareTupleGroupByLocation.First();
					var malwareAtThisLocation = malwareTupleGroupByLocation.Count();

					if (malwareAtThisLocation == 1)
					{
						if (malwareTupleGroupByLocation.Single().Component2.TicksAtLocation == 0)
						{
							var @event = new MalwarePropogationEvent() {
								LocationEntityId = subsystemTuple.Entity.Id,
								Result = MalwarePropogationEvent.MalwarePropogationResult.InfectionSpread,
							};
							_eventSystem.Publish(@event);
						}
					}
					else if (malwareAtThisLocation > 1)
					{
						var genomes = malwareTupleGroupByLocation.GroupBy(t => t.Component1.Value).Select(g => g.Key).ToArray();
						var aggregateVisibility = malwareTupleGroupByLocation.Aggregate(0, (v, mt) => v |= mt.Component4.VisibleTo);
						var @event = new MalwarePropogationEvent() {
							LocationEntityId = subsystemTuple.Entity.Id,
						};

						if (genomes.Length > 1)
						{
							foreach (var genome in genomes)
							{
								malwareTuple.Component1.Value |= genome;
							}
							@event.Result = MalwarePropogationEvent.MalwarePropogationResult.InfectionMutated;
						}
						else
						{
							@event.Result = MalwarePropogationEvent.MalwarePropogationResult.AlreadyInfected;
						}
						malwareTuple.Component4.VisibleTo = aggregateVisibility;
						_eventSystem.Publish(@event);

						// combine the genomes
						foreach (var otherMalware in malwareTupleGroupByLocation.Skip(1))
						{
							otherMalware.Entity.Dispose();
						}

						// reset spread interval
						malwareTuple.Component3.TicksRemaining = -1;
					}

					switch (malwareTuple.Component3.TicksRemaining)
					{
						case -1:
							malwareTuple.Component3.TicksRemaining = malwareTuple.Component3.Interval + _rngSystem.Next(-1 * malwareTuple.Component3.IntervalVariation, malwareTuple.Component3.IntervalVariation);
							break;
						case 0:
							Propogate(malwareTuple, subsystemTuple);
							malwareTuple.Component3.TicksRemaining = malwareTuple.Component3.Interval;
							break;
						default:
							malwareTuple.Component3.TicksRemaining = malwareTuple.Component3.TicksRemaining - 1;
							break;
					}

				}
			}
		}

		private void Propogate(ComponentEntityTuple<MalwareGenome, CurrentLocation, MalwarePropogation, MalwareVisibility> malwareTuple, ComponentEntityTuple<Subsystem, GraphNode> subsystemTuple)
		{
			if (_rngSystem.Next(0, 99) > malwareTuple.Component3.RollThreshold)
			{
				var exitNodes = subsystemTuple.Component2.ExitPositions.Keys.ToArray();

				// TODO: currently the direction to spread in is picked randomly by the PRNG - maybe have a more deterministic solution
				var propogateTo = exitNodes[_rngSystem.Next(0, exitNodes.Length)];

				if (_entityFactoryProvider.TryCreateEntityFromArchetype(malwareTuple.Entity.CreatedFromArchetype, out var entity)
					&& _malwareMatcher.TryGetMatchingEntity(entity.Id, out var newMalwareTuple))
				{
					newMalwareTuple.Component1.Value = malwareTuple.Component1.Value;
					newMalwareTuple.Component4.VisibleTo = malwareTuple.Component4.VisibleTo;

					_movementSystem.AddVisitor(propogateTo, newMalwareTuple.Entity.Id);
				}
			}
		}

		public void Dispose()
		{
			_malwareMatcher?.Dispose();
			_subsystemMatcher?.Dispose();
		}
	}
}

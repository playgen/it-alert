using System.Linq;
using Engine.Components;
using Engine.Systems;
using PlayGen.ITAlert.Simulation.Common;
using PlayGen.ITAlert.Simulation.Components.Common;
using PlayGen.ITAlert.Simulation.Components.EntityTypes;
using PlayGen.ITAlert.Simulation.Components.Movement;
using PlayGen.ITAlert.Simulation.Modules.Malware.Components;

namespace PlayGen.ITAlert.Simulation.Modules.Malware.Systems.Movement
{
	/// <summary>
	/// TODO: we could do this via the bandwidth resource indirection and a resource to movement cost resource system extension, but this is impler for now
	/// </summary>
	public class AdjacenetMalwareIncreaseMovementCostSystem : ISystem, ITickableSystem
	{
		private const decimal MovementCostIncreasePerLevel = 0.5m;

		private readonly ComponentMatcherGroup<Connection, GraphNode, MovementCost> _connectionMatcherGroup;

		private readonly ComponentMatcherGroup<Subsystem, GraphNode, Visitors> _subsystemMatcherGroup;
		
		private readonly ComponentMatcherGroup<MalwareGenome, CurrentLocation> _malwareMatcherGroup;

		public AdjacenetMalwareIncreaseMovementCostSystem(IMatcherProvider matcherProvider)
		{
			_connectionMatcherGroup = matcherProvider.CreateMatcherGroup<Connection, GraphNode, MovementCost>();
			_subsystemMatcherGroup = matcherProvider.CreateMatcherGroup<Subsystem, GraphNode, Visitors>();
			_malwareMatcherGroup = matcherProvider.CreateMatcherGroup<MalwareGenome, CurrentLocation>();
		}

		#region Implementation of ITickableSystem

		public void Tick(int currentTick)
		{
			foreach (var connectionTuple in _connectionMatcherGroup.MatchingEntities)
			{
				var adjacentMalwareCount = connectionTuple.Component2.EntrancePositions.Keys
					.Concat(connectionTuple.Component2.ExitPositions.Keys)
					.Distinct()
					.Join(_subsystemMatcherGroup.MatchingEntities,
						o => o,
						i => i.Entity.Id,
						(o, i) => i)
					.Select(s => s.Component3.Values.Count(v => _malwareMatcherGroup.MatchingEntityKeys.Contains(v)))
					.Count(mc => mc > 0);	// should give us 0, 1 or 2

				connectionTuple.Component3.Value = SimulationConstants.DefaultMovementCost + (MovementCostIncreasePerLevel * adjacentMalwareCount);
			}
		}

		#endregion

		public void Dispose()
		{
			// nothing to dispose
		}

	}
}

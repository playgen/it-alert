using System;
using System.Collections.Generic;
using System.Linq;
using Engine.Components;
using Engine.Entities;
using Engine.Systems;
using Engine.Util;
using PlayGen.ITAlert.Simulation.Common;
using PlayGen.ITAlert.Simulation.Components.Common;
using PlayGen.ITAlert.Simulation.Components.EntityTypes;
using PlayGen.ITAlert.Simulation.Components.Malware;
using PlayGen.ITAlert.Simulation.Components.Movement;
using PlayGen.ITAlert.Simulation.Systems.Movement;
using Zenject;

namespace PlayGen.ITAlert.Simulation.Systems.Malware
{
	public class MalwarePropogationSystem : ISystem, ITickableSystem
	{

		private readonly IEntityFactoryProvider _entityFactoryProvider;

		private readonly ComponentMatcherGroup<MalwareGenome, CurrentLocation, MalwarePropogation, MalwareVisibility> _malwareMatcher;

		private readonly ComponentMatcherGroup<Subsystem, GraphNode> _subsystemMatcher;

		private readonly RNGSystem _rngSystem;

		private readonly MovementSystem _movementSystem;

		public MalwarePropogationSystem(IMatcherProvider matcherProvider,
			IEntityFactoryProvider entityFactoryProvider,
			RNGSystem rngSystem,
			MovementSystem movementSystem)
		{
			_entityFactoryProvider = entityFactoryProvider;
			_rngSystem = rngSystem;
			_movementSystem = movementSystem;

			// TODO: refactor to use tuple matcher
			_malwareMatcher = matcherProvider.CreateMatcherGroup<MalwareGenome, CurrentLocation, MalwarePropogation, MalwareVisibility>();
			_subsystemMatcher = matcherProvider.CreateMatcherGroup<Subsystem, GraphNode>();
		}

		public void Tick(int currentTick)
		{
			foreach (var malwareTupleGroupByLocation in _malwareMatcher.MatchingEntities
				.Where(mt => mt.Component2.Value.HasValue)
				.GroupBy(mt => mt.Component2.Value))
			{
				if (_subsystemMatcher.TryGetMatchingEntity(malwareTupleGroupByLocation.Key.Value, out var subsystemTuple))
				{
					foreach (var malwareTuple in malwareTupleGroupByLocation)
					{
						switch (malwareTuple.Component3.TicksRemaining)
						{
							case -1:
								malwareTuple.Component3.TicksRemaining = malwareTuple.Component3.Interval + _rngSystem.Next(-1 * malwareTuple.Component3.IntervalVariation, malwareTuple.Component3.IntervalVariation);
								break;
							case 0:
								Propogate(malwareTuple, subsystemTuple);
								malwareTuple.Component3.TicksRemaining = malwareTuple.Component3.Interval;
								break;
							default:
								malwareTuple.Component3.TicksRemaining = malwareTuple.Component3.TicksRemaining;
								break;
						}
					}
				}
			}
		}

		private void Propogate(ComponentEntityTuple<MalwareGenome, CurrentLocation, MalwarePropogation, MalwareVisibility> malwareTuple, ComponentEntityTuple<Subsystem, GraphNode> subsystemTuple)
		{
			if (_rngSystem.Next(0, 99) > malwareTuple.Component3.RollThreshold)
			{
				var exitNodes = subsystemTuple.Component2.ExitPositions.Keys.ToArray();
				
				// TODO: currently the direction to spread in is picked randomly by the PRNG - maybe have a more deterministic solution
				var propogateTo = exitNodes[_rngSystem.Next(0, exitNodes.Length)];

				if (_entityFactoryProvider.TryCreateEntityFromArchetype(Archetypes.Malware.Archetype.Name, out var entity)
					&& _malwareMatcher.TryGetMatchingEntity(entity.Id, out var newMalwareTuple))
				{
					newMalwareTuple.Component1.Value = malwareTuple.Component1.Value;
					newMalwareTuple.Component4.VisibleTo = malwareTuple.Component4.VisibleTo;

					_movementSystem.AddVisitor(propogateTo, newMalwareTuple.Entity.Id);
				}
			}
		}

	}
}

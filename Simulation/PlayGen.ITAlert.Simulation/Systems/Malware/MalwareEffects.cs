using System;
using System.Collections.Generic;
using System.Linq;
using Engine.Components;
using Engine.Entities;
using Engine.Systems;
using Engine.Util;
using PlayGen.ITAlert.Simulation.Common;
using PlayGen.ITAlert.Simulation.Components.Common;
using PlayGen.ITAlert.Simulation.Components.Malware;
using Zenject;

namespace PlayGen.ITAlert.Simulation.Systems.Malware
{
	public class MalwareEffects : Engine.Systems.System, ITickableSystem
	{
		private readonly Dictionary<string, IMalwareEffect> _malwareEffects;

		private readonly ComponentMatcherGroup _malwareHostMatcher;

		public MalwareEffects(ComponentRegistry componentRegistry, 
			EntityRegistry entityRegistry, 
			SystemRegistry systemRegistry,
			// TODO: remove zenject dependency when implicit optional collection paramters is implemented
			[InjectOptional] List<IMalwareEffect> malwareEffectExtensions)	
			: base(componentRegistry, entityRegistry)
		{
			_malwareEffects = malwareEffectExtensions.ToDictionary(k => k.GeneName, v => v);

			_malwareHostMatcher = componentRegistry.CreateMatcherGroup(new[] { typeof(MalwareGenome), typeof(CurrentLocation) });
			componentRegistry.RegisterMatcher(_malwareHostMatcher);
		}

		public void Tick(int currentTick)
		{
			var malwareHosts = _malwareHostMatcher.MatchingEntities;

			foreach (var malwareHost in malwareHosts)
			{
				//TODO: find a way of returning these directly from the matcher
				MalwareGenome malwareGenome;
				CurrentLocation currentLocation;

				Entity currentLocationEntity;
				EntityTypeProperty currentLocationTypeProperty;

				if (malwareHost.TryGetComponent(out malwareGenome)
					&& malwareHost.TryGetComponent(out currentLocation)
					// test the malware host's current location
					&& EntityRegistry.TryGetEntityById(currentLocation.Value, out currentLocationEntity)
					&& currentLocationEntity.TryGetComponent(out currentLocationTypeProperty))
				{
					switch (currentLocationTypeProperty.Value)
					{
						case EntityType.Subsystem:
							foreach (var activeGene in malwareGenome.Value)
							{
								IMalwareEffect currentEffect;
								if (_malwareEffects.TryGetValue(activeGene, out currentEffect))
								{
									currentEffect.OnActive(malwareHost);
								}
							}
							break;

						default:
							foreach (var malwareEffect in _malwareEffects.Values)
							{
								malwareEffect.Reset(malwareHost);
							}
							break;
					}
				}
				else
				{
					//TODO: log this as it means an archetype is misconfigured 
				}

			}


		}

	}
}

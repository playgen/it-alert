using System;
using System.Collections.Generic;
using System.Linq;
using Engine.Components;
using Engine.Entities;
using Engine.Util;
using PlayGen.ITAlert.Simulation.Common;
using PlayGen.ITAlert.Simulation.Components.Properties;

namespace PlayGen.ITAlert.Simulation.Systems.Malware
{
	public class MalwareEffects : Engine.Systems.System
	{
		private readonly Dictionary<string, IMalwareEffect> _malwareEffects;

		public MalwareEffects(ComponentRegistry componentRegistry, EntityRegistry entityRegistry) 
			: base(componentRegistry, entityRegistry)
		{
			// load the malware effect classes, make this extensible
			_malwareEffects = ModuleLoader.InstantiateTypesImplementing<IMalwareEffect>()
				.ToDictionary(k => k.GeneName, v => v);
		}

		public override void Tick(int currentTick)
		{
			var malwareHosts = ComponentRegistry.GetComponentEntitesImplmenting<MalwareGenome>();

			foreach (var malwareHost in malwareHosts)
			{
				CurrentLocationProperty currentLocationProperty;
				Entity currentLocation;
				EntityTypeProperty currentLocationTypeProperty;

				if (malwareHost.Entity.TryGetComponent(out currentLocationProperty)
					&& EntityRegistry.TryGetEntityById(currentLocationProperty.Value, out currentLocation)
					&& currentLocation.TryGetComponent(out currentLocationTypeProperty))
				{
					switch (currentLocationTypeProperty.Value)
					{
						case EntityType.System:
							foreach (var activeGene in malwareHost.Value)
							{
								IMalwareEffect currentEffect;
								if (_malwareEffects.TryGetValue(activeGene, out currentEffect))
								{
									currentEffect.OnActive(malwareHost.Entity);
								}
							}
							break;

						default:
							foreach (var malwareEffect in _malwareEffects.Values)
							{
								malwareEffect.Reset(malwareHost.Entity);
							}
							break;
					}
				}
				else
				{
					//TODO: log this as it means an archetype is misconfigured 
				}

			}


		}

	}
}

using System;
using System.Collections.Generic;
using System.Linq;
using Engine.Components;
using Engine.Entities;
using Engine.Util;
using PlayGen.ITAlert.Simulation.Common;
using PlayGen.ITAlert.Simulation.Components.Properties;

namespace PlayGen.ITAlert.Simulation.Systems.Malware
{
	public class MalwareEffects : Engine.Systems.System
	{
		private readonly Dictionary<string, IMalwareEffect> _malwareEffects;

		private readonly ComponentMatcherGroup _malwareHostMatcher;

		public MalwareEffects(ComponentRegistry componentRegistry, EntityRegistry entityRegistry) 
			: base(componentRegistry, entityRegistry)
		{
			// load the malware effect classes, make this extensible
			_malwareEffects = ModuleLoader.InstantiateTypesImplementing<IMalwareEffect>()
				.ToDictionary(k => k.GeneName, v => v);

			_malwareHostMatcher = new ComponentMatcherGroup(new[] { typeof(MalwareGenome), typeof(CurrentLocationProperty) });
			componentRegistry.RegisterMatcher(_malwareHostMatcher);
		}

		public override void Tick(int currentTick)
		{
			var malwareHosts = _malwareHostMatcher.MatchingEntities;

			foreach (var malwareHost in malwareHosts)
			{
				//TODO: find a way of returning these directly from the matcher
				MalwareGenome malwareGenome;
				CurrentLocationProperty currentLocationProperty;

				Entity currentLocation;
				EntityTypeProperty currentLocationTypeProperty;

				if (malwareHost.TryGetComponent(out malwareGenome)
					&& malwareHost.TryGetComponent(out currentLocationProperty)
					// test the malware host's current location
					&& EntityRegistry.TryGetEntityById(currentLocationProperty.Value, out currentLocation)
					&& currentLocation.TryGetComponent(out currentLocationTypeProperty))
				{
					switch (currentLocationTypeProperty.Value)
					{
						case EntityType.Subsystem:
							foreach (var activeGene in malwareGenome.Value)
							{
								IMalwareEffect currentEffect;
								if (_malwareEffects.TryGetValue(activeGene, out currentEffect))
								{
									currentEffect.OnActive(malwareHost);
								}
							}
							break;

						default:
							foreach (var malwareEffect in _malwareEffects.Values)
							{
								malwareEffect.Reset(malwareHost);
							}
							break;
					}
				}
				else
				{
					//TODO: log this as it means an archetype is misconfigured 
				}

			}


		}

	}
}
